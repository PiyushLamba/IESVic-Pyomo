Home

## Welcome to the IESVic Pyomo for OSeMOSYS Wiki Page!

This project was developed by the University of Victoria's [Institute for Integrated Energy Systems](https://www.uvic.ca/research/centres/iesvic/index.php) and aims at developing an energy system model for the Canadian province of British Columbia. Particularly, this study seeks to understand the economic and technical feasibilities of decarbonizing the province's building, transport and industrial sectors with electrification and power-to-gas transitions. 

This wiki contains the basics of the project's development with detailed explanations on energy modelling and how to use [Pyomo](https://www.pyomo.org/) for developing an [OSeMOSYS](http://www.osemosys.org/) model that meets the goals of our project. Additionaly, we hope this project will encourage other members of the energy sector, policy makers and the modelling community at large to opt for Pyomo when developing their models, as well as serve as a reference work for developping energy system models in the future.  

## Project authors:
* Cristiano Curi Fernandes - Third year Electrical Engineering student at the [University of Victoria](https://www.uvic.ca/)
* Henry Jiang - Fourth year Computer Science student at the [University of Victoria](https://www.uvic.ca/)
* Piyush Lamba - Third year Computer Science student at the [University of Victoria](https://www.uvic.ca/)
* Dr. Jacob Monroe - Project supervisor (IESVic)

![](https://scontent.fplu4-1.fna.fbcdn.net/v/t1.18169-9/10606274_624353777691825_443076804849517334_n.jpg?_nc_cat=108&ccb=1-5&_nc_sid=973b4a&_nc_ohc=QY2EcLOO6cQAX_Ae5rv&_nc_ht=scontent.fplu4-1.fna&oh=e53494962bc3b193aa47cee894a2a563&oe=61C77A1D)

------------------------------------------------------------------------------------------------------

1 Introduction to Energy Modelling and OSeMOSYS

## 1.1 Energy Sector Modelling

The energy industry is a vital part of our everyday lives. It is responsible for powering our house appliances, our communication systems, producing heat during the winter and powering AC units during the summer. It is also a structural component of a country’s supply chain, without it, the logistics and execution of transporting goods across drastically less efficient and time consuming.

Energy systems models aim at representing all components and processes in energy systems in a mathematical manner, through equations. These models provide useful insights into the dynamics of the energy system but can never truly predict the future of the energy grid. Additionally, it is important to note that energy will follow the path described by the diagram below inside any energy system.

![](https://github.com/criscfer/IESVic-Pyomo-Test/blob/main/Wiki%20Images/Energy%20System%20Representation.jpg)

Energy resources are either domestically extracted or imported; then they are converted into electricity inside powerplants. Finally, this electricity is transported to the end-user   via the energy grid, where it is consumed. 

To better study an energy system, it is often desired to represent it using a Reference Energy System (RES). A RES is a simplified graphical representation of the energy system under analysis and can cover possible policy development paths. Reference Energy Systems should be a minimum representation of reality needed to answer the relevant policy questions being addressed.

## 1.2 Motivation: Why Model Energy Systems?

“A sustainable energy system can lift people out of poverty around the world” [1].  In a rapidly evolving world, energy systems continue to get increasingly complex and capital intensive, requiring evermore comprehensive planning and analysis. 

A comprehensive energy system analysis denotes the inexistence of a “one size fits all” solution [1], since this analysis will vary depending on the country’s infrastructure, current environmental policies that dictate the established energy system, economic profile of the country, and many other region-specific factors. 

Often, we see short-term necessities taking precedence over long-term investments on policies that dictate the energy system which could lead the path towards a sustainable energy grid if given the deserved priorities.  Energy modelling can benefit both engineers and policy makers, as it helps mitigate uncertainty of future scenarios while accounting for necessities, available resources and demands of the local population. Moreover, if grounded with sound project economics, modelling can have a majorly positive impact on the environment and bring with it economic prosperity [1].  

## 1.3 What is OSeMOSYS?

“OSeMOSYS is an open source modelling system for long-run integrated assessment and energy planning” [2]. OSeMOSYS has been used to develop and document over 60 (sixty) national energy models and is available in three different programming languages:

* GNU MathProg
* Python (Pyomo)
* GAMS

The MathProg and Pyomo implementations are able to “run free and openly from source to solver” [2].  OSeMOSYS allows us to run models from a  region-based analysis all the way to a national, continental, or even global scale outlook, adjusting its scope according to the researcher, engineer, or policy maker’s necessity.

## 1.4 References

[1] [Energy and Flexibility Modelling: OSeMOSYS & FlexTool - Open University Course](https://www.open.edu/openlearncreate/course/view.php?id=6817)
 
[2] [OSeMOSYS - Home Page](http://www.osemosys.org/)

[3] [OSeMOSYS Documentation](https://osemosys.readthedocs.io/en/latest/)

[4] [OSeMOSYS User Manual - 2015](https://archive.org/details/manualzilla-id-5811946/mode/2up)

[5] [UCL Energy Institute Models - OSeMOSYS](https://www.ucl.ac.uk/energy-models/models/osemosys)

-----------------------------------------------------------------------------------------------------

2 Introduction to Pyomo

# 2.1 What is Pyomo?
Pyomo, or the Python Optimization Modelling Objects software, is an open-source package built for the Python scripting language. With Pyomo, the user can define abstract and concrete optimization problems to be solved by standard open-source and commercial solvers, such as Gurobi, IBM’s CPLEX and GLPK.

Pyomo shares its capabilities with other algebraic modelling languages, such as AMPL, GAMS and AIMMS, while taking advantage of Python’s powerful libraries (Pandas, Numpy, Matplotlib, etc) and the language’s object-oriented nature. Together with the Coopr software library, Pyomo also integrates IBM’s COIN-OR open-source initiative for operations research software [1]. 

# 2.2 What is a Linear Program?
Linear programs are computer programs that employ optimization techniques to maximize, or to minimize a linear function. Typically, a linear optimization of an objective function is subject to one or more constraining functions. These constraints together bound the solution space of the problem, which is the graphical space that contains all feasible variable solutions to the problem

![Feasible Solution Space](https://eng.libretexts.org/@api/deki/files/39652/Screenshot_(84).png?revision=1)

Linear programming theory is part of the operations research academic field and is extensively used in different industries and applications to solve different kinds of problems, such as profit maximization in businesses, shadow-price calculations in economics and the limit analysis of planar trusses in civil engineering [2]. In the case of this project, linear programming is extremely useful for finding the minimum cost of the implementation of renewable energy technologies in contrast with the currently available energy system in place in British Columbia.

# 2.3 Motivation: why choose Pyomo?

The MathProg modelling language is simple and objective for writing linear programs, which typically consist of a few component declarations:

* Decision variables
* Target (objective) function
* Constraints 
* Data (model parameters)

The drawback for MathProg as a programming language, however, is its learning curve is attached directly to the understanding of linear optimization and the crude mathematics that describes linear problems in operations research. Pyomo allows us to achieve the same results from a linear problem by using a scripting language that does not require a deep understanding of operations research.

Pyomo diverges from MathProg by keeping a language that likens spoken English, while still meeting the goals of any modelling language (separation of model declarations from model data and keeping a concise problem definition). By taking advantage of Python’s readily available and powerful libraries for mathematical operations [3], such as Numpy, Pandas, Matplotlib and many others, Pyomo may also host a complex workflow that is otherwise hard to construct using MathProg. Furthermore, the use o Python as a modelling language can encourage a larger community of engineers and researchers to engage with the model development process, as Pyomo is open-source and Python is ranked as StackOverflow’s [fourth most commonly used language](https://learnworthy.net/stackoverflow-listed-the-most-commonly-used-programming-languages/) for data analysis.

# 2.4 How to use Pyomo?

## 2.4.1 Installation

In order to use Pyomo for modelling energy systems, one will need to install the following programs and libraries into their machine:

1. Anaconda Python: latest Python version should work for Pyomo models, but you can change the distribution version after installation. Download your individual toolkit [here](https://www.anaconda.com/products/individual)
2. Create an Anaconda environment: after downloading Anaconda, open the Anaconda Prompt and create an environment to run your model.
* To create an environment run the following command: `conda create --name myenv python=3.6` (this will tell Anaconda to install `Python v3.6` into the environment)
* To install Python packages into your newly created environment, use the pip command: `pip install pyomo` (this installs Pyomo into the environment) after you activate it
3. To run your newly created environment, use the command `conda activate myenv` 
4. The Python installation comes with some basic preinstalled libraries, but you may also wish to install other packages, such as [Pandas](https://pandas.pydata.org/) (`pip install pandas`), or [Numpy](https://numpy.org/) (`pip install numpy`)
5. Install the solvers to solve the linear problems.
* To install GLPK on Windows, you can follow this [tutorial](http://www.osemosys.org/uploads/1/8/5/0/18504136/glpk_installation_guide_for_windows10_-_201702.pdf) by OSeMOSYS creators at the KTH Royal Institute of Technology
* If you wish to install IBM’s CPLEX, you can follow their [tutorial](https://www.ibm.com/support/pages/downloading-ibm-ilog-cplex-optimization-studio-v1290) installation
* Other commercial and open-source solvers are available as well, such as [Gurobi](https://www.gurobi.com/gurobi-and-anaconda-for-windows/), [CBC](https://projects.coin-or.org/Cbc) and [IPOPT](https://coin-or.github.io/Ipopt/index.html)

## 2.4.2 Modelling components

Pyomo models take advantage of Python’s object-oriented nature to assist the programmer when creating optimization models. Model objects are Python classes and as such contain many internal functions that can take arguments to construct the component [4]. The main components of any Pyomo model are:

* Parameters
* Sets
* Variables
* Objective functions
* Constraints

The model components in Pyomo are supported by most Algebraic Modeling Languages (AMLs) [5], this way a Pyomo model can take in data from files in AML / AMPL data formats as input to construct the model instances. To illustrate the behavior of components inside a model, we can use a simple illustration: an optimization model is comprised of different equations, where at least one is the objective function and the remaining (non-objective functions) are constraints to our problem of study. Inside each equation we will have the decision variables, called Variables in the Pyomo script, each of which is accompanied by a corresponding term, called a Parameter inside Pyomo. 

In the example below, function f(x,y) is a two-dimensional multi-variable  equation with variables x and y and parameters  a, b and c. Each variable, in this case x and y are also indexed by indices i and j, respectively; inside the Pyomo model these indices would be called Sets.

![](https://github.com/criscfer/IESVic-Pyomo-Test/blob/main/Wiki%20Images/2-4%20Example%20Equation.jpg)

## 2.4.3 Modelling examples: concrete X abstract

As it was previously mentioned, optimization models in Pyomo are implemented as Python objects (classes), which will contain the model’s components inside them. A Pyomo model can either be Concrete, or Abstract and the main difference between these two implementations is the construction process of the model when the Python script is run.
	
Pyomo Concrete Models are used to build models which receive input data to their Sets and Parameters as these components are declared, then Python will immediately create an instance of the model to be given to the solver. An Abstract Model, however, can assume a less strict form, where the engineer may declare model components without necessarily assigning their corresponding data values immediately, this way, the model can serve as a more generic version of the problem and can receive data from different sources after the model instance is created [5]. “_Abstract models include additional components for managing the declaration of model data, as well as logic for data initialization and validation_” [5].

To illustrate the difference between the Concrete and Abstract model options in Pyomo, let us look into the same example problem being implemented using these two different model types. The problem in question is taken from [Operations Research: Models and Methods by Jensen & Bard](https://books.google.com.br/books/about/Operations_Research_Models_and_Methods.html?id=8uEeAQAAIAAJ&redir_esc=y) and has been [implemented as a Pyomo Concrete Model](https://github.com/brentertainer/pyomo-tutorials/blob/master/introduction/02-lp-pyomo.ipynb) by professor Brent Austgen of the University of Texas Austin as part of a workshop on optimization tools in Python. You can watch his [full lecture](https://www.youtube.com/watch?v=pxCogCylmKs) for a deeper dive into Pyomo and optimization tools. The [Abstract Model implementation](https://github.com/criscfer/IESVic-Pyomo-Test/blob/main/Pyomo%20and%20Pandas%20Example%20Model/Pyomo_LP_Example.ipynb) of the problem has been carried out by Cristiano Fernandes of IESVic and is available inside this GitHub repository.

The main difference between Concrete and Abstract models that is noticible between the given examples is what is called [model instantiation](https://pyomo.readthedocs.io/en/stable/working_abstractmodels/instantiating_models.html), which is the procedure of creating a model instance that is passed to the solver in order to get a solution. An instance of a model component is the creation of that component in memory by Pyomo and its initialization to the appropriate value; this process occurs in unique ways between Concrete and Abstract models.

Concrete model components are created and initialized as they are added to the model object, but Abstract model components are treated as "empty boxes" by Pyomo until an instance of the problem is created by the user, that is, in Abstract models, equations and components take prescedence over data, allowing the programmer to test the model for different datasets without the need for multiple model instances to be created. To create an Abstractmodel instance, we can simply use the `create_instance()` method from Pyomo and **pass the instance of the model to the solver**

```
instance = model.create_instance() # create the abstract model instance
opt = SolverFactory('glpk') # choose solver to be used
final_result = opt.solve(instance, tee=True) # pass instance to solver and display results on screen
```

## 2.4.4 Data usage inside Pyomo models

### 2.4.4.1 AMPL data files and the `pyomo` command

As shown by the Abstract Model example, a Pyomo abstract model can accept data input from sources other than the script itself, which allows for a model design and development that is independent of having available data for testing. This data can be imported into the model through data commands in a data file, or through ModelData objects and even by using data manipulation libraries, such as Pandas for extracting information from spreadsheets.

Pyomo's data command files closely resemble AMPL's data commands, but are not identical to one another. The main commands in a data file are `set`, `parameter` and `import`, when data is not present in the data file, but rather contained in a separate CSV, or other types of files. Additionally, Pyomo provides the `data` and `end` commands, which do not serve a major role inside the data file, but allow for compatibility between Pyomo data files and AMPL scripts that define data commands.

More about using data files is available in chapter 6 of the Pyomo Optimization textbook [5]. An example of a typical Pyomo data file is found [here](https://github.com/criscfer/OSeMOSYS_Pyomo/blob/master/UTOPIA_2015_08_27.dat). It is also interesting to note that AMPL-like data files are also sometimes used by MathProg models, although with some minor syntax differences to the data files used by Pyomo models, meaning one could safely translate data files from a MathProg model to be used by a Pyomo model. 

The `pyomo` command is used to run the model from the command line and is able to accpet data files, then read their information and pass to the solver to apply to the model. Here is an example to illustrate its use: `pyomo solve --solver=glpk my_model.py my_data.dat --summary`. In this example, the following steps will take place after the command is executed:
* `pyomo solve`: evoke pyomo from the command line and inform of a problem to be solved
* `--solver=glpk`: pass the problem information to the chosen solver (model definitions and model data)
* `my_model.py`: give the Pyomo model file with model definitions
* `my_data.dat`: give the Pyomo data file with model data information

### 2.4.4.2 Using Pandas for data manipulation

One of the ways to initialize model parameters and sets in Pyomo is through the data processing library, Pandas. Pandas' [data frames](https://pandas.pydata.org/docs/user_guide/dsintro.html#dataframe) allow us to retrieve data from spreadsheets and treat them as a SQL table, or a Python dictionary. The correct manipulation of these data frames can facilitate the initialization process by parsing individual parts of a large spreadsheet one step at a time. 

In our OSeMOSYS model, Pandas was employed to allow us to bypass data imports through other means, such as the ModelData functionality of Pyomo and to allow the model to run entirely from the IDE. Our function for data processing is shown below.

```
def Process_Data(data, component="set"): # Where data is a Pandas Data Frame
    data = data.to_dict('list') # Transform dataframe into dictionary of lists
    #print(data)
    included = data.pop('Included') # Get the 'Included' column as a separate list (alternative way of achieving this: list(data.values())[0] )
    value = list(data.values())[-1] # Get parameter values as a separate list
    if component == "set": # Initialize sets
        initializer = []
        for k in range(len(value)):
            if included[k] == "Yes":
                initializer.append(value[k])
    elif component == "parameter": # Initialize parameters
        initializer = {}
        sets = list(data.values())[0:-1]
        set_tuples = [tuple([i[j] for i in sets]) for j in range(len(sets[0]))] # Get sets indexing the parameter as tuples
        for k, i, j in zip(included, set_tuples, value):
            if(k == 'No'):
                continue
            if not math.isnan(j):
                initializer[i] = j
    return initializer
```

It is important to note that our data parsing function is **application specific**, that is, it serves the purpose of parsing the data in the format we are feeding into the model. If you have data provided from an outside source, then the data frames need to be carefully constructed to fit in the appropriate sets and parameters for your model.

# 2.5 References   

[1] [Pyomo: modeling and solving mathematical programs in Python](https://link.springer.com/article/10.1007/s12532-011-0026-8)

[2] [Linear Programming - Wolfram Math World](https://mathworld.wolfram.com/LinearProgramming.html)

[3] [Hover F. S., M.S. Triantafyllou; System Design for Uncertainty; 7.4: Linear Programming](https://eng.libretexts.org/Bookshelves/Mechanical_Engineering/System_Design_for_Uncertainty_(Hover_and_Triantafyllou)/07%3A_Optimization/7.04%3A_Linear_Programming)

[4] [Pyomo Workshop: 2018](https://www.osti.gov/biblio/1525944-pyomo-workshop-summer)

[5] [Pyomo-Optimization Modelling in Python](https://link.springer.com/book/10.1007/978-3-030-68928-5)

[6] [AMPL](https://ampl.com/resources/the-ampl-book/chapter-downloads/)

[7] [Pyomo - Documentation](https://pyomo.readthedocs.io/en/stable/)

--------------------------------------------------------------------------------------------------------

3 The OSeMOSYS Model in Pyomo

# 3.1 Motivation: why model the energy system of British Columbia?

Remember in chapter 1 of this Wiki we said that energy system modelling is an important step for the economical and social development of different regions of the world. This concept is, terefore, applicable to Canada's province of British Columbia.

British Columbia is home to over 232,000 [indigenous people](https://www2.gov.bc.ca/gov/content/governments/indigenous-people), of which 67% are first nations, living on- and off-reserves. Furthermore, BC is home to over 470 [dairy farms](https://bcdairy.ca/dairy-farming-in-bc/) that sustain 12,500+ jobs in the province. These localized communities are, ultematelly, the major beneficients of a careful and thoughtful plan that leads BC towards the future of energy production and distribution.

The modelling process for an energy system as complex as British Columbia's can help us understand the needs of the different regions of the province and how, for example, climate change can effect the energy consumption throughout the province in contrast with how the energy industry is able to supply that energy. Capacity expansion planning of the enrgy systems of BC can mitigate the impacts of climate change, while leading the way towards a renewable energy matrix in the province and the modelling process lies at the heart of this endevour.


# 3.2 Basics of the model: sets, parameters, variables and lp formulation

As we discussed in chapter 2 of this wiki, the core of the modelling process for energy systems lies in mathematically describing the problem at hand and, to achieve this, we resort to linear programming. As the ccentral topic in optimization engineering and operations research, linear programming translates mathematical formulations into computer programs.

A linear program for our energy model, for example, is described mathematically as a series of constraints, one (or more) objective, and a series of decision variables indexed by sets and accompained by the model parameters that, as discussed in the previous chapter, together for the model equations. Typically, a linear program formulation will be written in the way described in chapter 2: an objective function is to be maximized, or minimized, under a series of constraints, while the decision variables obey their limiting sets.

A more detailed explanation on LP formulations is given in section 4.2.1 in chapter 4 of this wiki. What follows is a series of example lp formulations for our OSeMOSYS model and their equivalent representation in Pyomo. Bare in mind that the full description of the OSeMOSYS model is a combination of descriptions for the objective function, its constraints and the variable bounds for the problem. With these examples we hope to help you get more familiar with the OSeMOSYS model by giving a mathematical description of what you see in code to shorten the gap between theory and practice.

> minimize: OSeMOSYS Objective Function

> subject to:

>(...)

> EBb4 Energy Balance Each Year: 

![](https://github.com/criscfer/IESVic-Pyomo-Test/blob/main/Wiki%20Images/EBb4%20lp.jpg)

> Pyomo: 

```
def EBb4_EnergyBalanceEachYear4_rule(model, r, f, y):
    result1 = sum(
        model.RateOfActivity[r,l,t,m,y] * model.OutputActivityRatio[r,t,f,m,y] * 
        model.YearSplit[l,y] 
        
        for m in model.MODE_OF_OPERATION 
        for t in model.TECHNOLOGY 
        for l in model.TIMESLICE 
        if model.OutputActivityRatio[r,t,f,m,y] != 0
    )
    
    result2 = sum(
        model.RateOfActivity[r, l, t, m, y] * 
        model.InputActivityRatio[r, t, f, m, y] * 
        model.YearSplit[l, y] 
        
        for m in model.MODE_OF_OPERATION 
        for t in model.TECHNOLOGY 
        for l in model.TIMESLICE 
        if model.InputActivityRatio[r, t, f, m, y] != 0
    ) + sum(
        model.Trade[r,rr,l,f,y] * model.TradeRoute[r,rr,f,y] 
        
        for l in model.TIMESLICE 
        for rr in model.REGION
    ) + model.AccumulatedAnnualDemand[r,f,y]

    return result1 >= result2
```
> (...)

> Nonstorage Constraint:

![](https://github.com/criscfer/IESVic-Pyomo-Test/blob/main/Wiki%20Images/NonStorageConstraint%20lp.jpg)

> Pyomo:

```
def NonStorageConstraint_rule(model,r,l,t,m,y): 
    if sum(model.TechnologyStorage[r,t,s,m] for s in model.STORAGE) == 0:
        return model.RateOfActivity[r,l,t,m,y] >= 0
    else:
        return Constraint.Skip
```

> (...)

> SC2 Upper Limit:

![](https://github.com/criscfer/IESVic-Pyomo-Test/blob/main/Wiki%20Images/SC2%20Upper%20Limit%20lp.jpg)

> Pyomo:

```
def SC2_UpperLimit_rule(model, r, s, l, y):
    result = sum(
        model.NewStorageCapacity[r,s,yy] + model.ResidualStorageCapacity[r,s,y] 
        for yy in model.YEAR 
        if y-yy <= model.OperationalLifeStorage[r,s] and y - yy >= 0
    )
    
    return model.StorageLevelTSStart[r,s,l,y] <= result 
```

Note that in the images, the constraints and variable bounds / set indices are separated by the dashed line.

# 3.3 Model translation from GNU MathProg to Pyomo

As we have previously mentioned in this wiki, OSeMOSYS supports three main implementations for its energy models: GNU MathProg, Python, GAMS. The approaches in these languages, mainly MathProg and Pyomo, are similar, in that they seek to divide the system into its separate components (sets and parameters) and establish an objective to be obtained under defined constraints.

The key differences in constructing an energy model using MathProg and Python (Pyomo) are presented in the following table:

|Language Capability |Pyomo  | GNU MathProg|
--- | --- | ---|
|Mathematically represents model components (sets, parameters, constraints, objective and variables)|Yes|Yes|
|Supports real world data as input to mathematical model|Yes|Yes|
|Has access to programming libraries for data processing and performing complex mathematical operations|Yes|No|
|Can hold model data within model file|Yes|Yes|
|Capable of evoking a linear solver from within the model file|Yes|No|

As we can see, the appeal for Pyomo resides in its extra capabilities over MathProg, especially in the data magement, data processing and reusability aspects. Additionally, as seen in Chapter 2 of this wiki, Pyomo allows you to create abstract models, which can receive data after the model has been created, a functionallity that is not available in MathProg.

The recommended approach to translate a model from MathProg to Pyomo is to copy the code from MathProg to a Python script in sections (building blocks), that is, first translate the model sets, parameters, and variables, then the model functions (objective and constraints). This will allow the programmer to concentrate in the differences in syntax between both languages and verify that the section of code has been correctly interpreted by Pyomo. Furthermore, this can facilitate the debugging step of the implementation, since Pyomo also offers debugging capabilities from within the script, such as access to model duals and slack values, which could be applied to the different parts of the code, then to the final version of the entire model for redundance. 

After migrating a model from MathProg to Pyomo, one can easily verify the implementation is correct by running both programs through the same solver, GLPK, or CPLEX, for example, and compare the results. If the mathematical formulation (LP format) is preserved between implementations and the outputs are within a small marginal difference, then the Pyomo (translated) model will have been fully and correctly created. Here, we see two example model formulations, in MathProg and in Pyomo.

```
# MATHPROG IMPLEMENTATION:
# A TRANSPORTATION PROBLEM
#
# This problem finds a least cost shipping schedule that meets
# requirements at markets and supplies at factories.
#
# References:
# Dantzig G B, "Linear Programming and Extensions."
# Princeton University Press, Princeton, New Jersey, 1963,
# Chapter 3-3.

set I;
/* canning plants */
set J;
/* markets */
param a{i in I};
/* capacity of plant i in cases */
param b{j in J};
/* demand at market j in cases */
param d{i in I, j in J};
/* distance in thousands of miles */
param f;
/* freight in dollars per case per thousand miles */
param c{i in I, j in J} := f * d[i,j] / 1000;
/* transport cost in thousands of dollars per case */
var x{i in I, j in J} >= 0;
/* shipment quantities in cases */
minimize cost: sum{i in I, j in J} c[i,j] * x[i,j];
/* total transportation costs in thousands of dollars */
s.t. supply{i in I}: sum{j in J} x[i,j] <= a[i];
/* observe supply limit at plant i */
s.t. demand{j in J}: sum{i in I} x[i,j] >= b[j];
/* satisfy demand at market j */
```

```
# PYOMO IMPLEMENTATION
from __future__ import division
from pyomo.environ import *
from pyomo.core import *
from pyomo.opt import SolverFactory

model = AbstractModel(name="Example") # Example model

# Model sets
model.I = Set() # Canning plants
model.J = Set() # Markets

# Model Parameters
model.a = Param(model.I) # Capacity of each plant
model.b = Param(model.J) # Market demands
model.d = Param(model.I, model.J) # Distance in thousand of miles
model.f = Param() # Freight in dollars per case per thousand miles
model.c = Param(model.I, model.J, initialize= model.f * model.d / 1000) # Transport
cost in thousands of dollars

# Model Variables
model.x = Var(model.I, model.J, bounds=(0, None)) # Shipment quantities in cases

# Objective Function
def Objective_cost(model):
return sum(model.c[i,j] * model.x[i,j] for i in model.I for j in model.J)
model.Cost = Objective(rule= Objective_cost, sense=minimize) # Total cost

# Model Constraints
def Supply_const(model, i):
result1 = sum(model.x[i,j] for j in model.J)
return result1 <= model.a[i]

model.supply = Constraint(model.I, rule=Supply_const) # Supply limits

def Demand_const(model, j):
result1 = sum(x[i,j] for i in model.I)
return result1 >= model.b[j]

model.demand = Constraint(model.J, rule=Demand_const)

# Solving the model
instance = model.create_instance()

opt = SolverFactory('glpk') # Choose solver to be used

final_result = opt.solve(instance, tee=True)
```

# 3.4 How to run the model

The Pyomo model of OSeMOSYS can be run from within a Python IDE of your choice, such as [Visual Studio Code](https://code.visualstudio.com/), [PyCharm](https://www.jetbrains.com/pycharm/), or the  [Spyder IDE](https://www.spyder-ide.org/), but it can also run directly from the command line when you have Anaconda added to your path variables and an [environment](https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html) in which you installed Pyomo.

If running the model from within an IDE, the portion of the main code, `pyomo-osemosys.py`, labeled `# Solver` must be included (it is commented out by default). To include the solver into the main code, simply uncomment the portion of the code below the label (multi-line comments in Python are indicated by triple quotation marks). In this case, you have two main ways in which you can run the code: through an AMPL data file as an input parameter, or through data processing using Pandas dataframes.

To use an AMPL data file within the code, the model instance must be created from the data file of your choice in the following way: `instance = model.create_instance(my_data_file)`. This is the default approach adopted by the team for running the code within an IDE. The second approach is to use Pandas dataframes, which are created from Excel spreadsheets. For this approach to work as expected, uncomment the sections of the code labeled `# Dataframes` and `# Data processing`, as well as the `# Solver`, then remove the data file argument from the instance creation on the `# Splver` section.

In order to run the code from the command line (or terminal), follow these steps:

1. Activate the Anaconda environment where Pyomo is installed

2. Change the directory to where you have the main model file. If you cloned this repository, that will be the `IESVic-Pyomo-Test` folder

3. Type the following command on your prompt: `pyomo solve --solver=my_solver pyomo-osemosys.py my_data_file.dat`, where:

* `my_solver` is the solver of your choice (GLPK, CPLEX, Gurobi, etc)

* `pyomo-osemosys.py` is the model file

* `my_data_file.dat` is the model data file (or path to the data file) in AMPL data format.

If solving the model with GLPK linear solver, the following arguments might be useful:

* `--summary`, displays a summary of the solution on screen

* `--wlp my_lp_file.lp`, writes the model problem in LP format to a separate file

# 3.5 References

1. [Agriculture in Canada - The Canadian Encyclopedia](https://www.thecanadianencyclopedia.ca/en/article/agriculture-in-canada)

2. [Energy Efficiency in British Columbia](https://www2.gov.bc.ca/gov/content/industry/electricity-alternative-energy/energy-efficiency-conservation)

3. [Energy Systems Modelling: Principles and Applications - H. Farzaneh](https://www.researchgate.net/publication/329905179_Energy_Systems_Modeling_Principles_and_Applications)

4. [First People's Map of British Columbia](https://maps.fpcc.ca/)

5. [Energy System Models - Science Drect](https://www.sciencedirect.com/topics/engineering/energy-system-models)

6. [Linear programming formulation examples - J. E. Beasley](http://people.brunel.ac.uk/~mastjjb/jeb/or/lpmore.html)


----------------------------------------------------------------------------------------------------------------------------------

4 Model Debugging

# 4.1 Motivation: how to debug linear programs

When dealing with linear programs we will almost always be looking into optimization problems (maximization and minimization). Solutions to these types of problems will conventionally follow the [simplex method](https://mathworld.wolfram.com/SimplexMethod.html), first described by american mathematician George Dantzig in 1947, which consists of an algebraic procedure with underlying geometric concepts that describe and solve linear problems by simplifying them to their corner-point feasible soltions (CPF solutions). This problem description allow us to solve simple problems by hand and relies on sofisticated software packages, capable of applying the method to more complex scenarios (higher geometric dimensions)

Beyound the simplex method which is the standard choice of commercial solvers, the software engineer needs different tools to help diagnose potential problems in the solution, or sources of infeasibility to the program. Linear programming theory hints to an useful tool that can be viewed as a verification method for the original problem solution, the [dual problem](https://mathworld.wolfram.com/DualityTheorem.html). "The constraint values of the primal problem are related to the variables of the dual problem. These variables are known as shadow prices" [1]. Furthermore, the strong duality theorem states that the value of the objective function is equal between the primal and the dual and can be used to get the shadow proces of constraints from the primal. The shadow price (or slack value) of a constraint is, according to the strong duality theorem, the variation to the objective function value when the right-hand side of that constraint is increased by the unit value [1].

# 4.2 Tools for debugging

## 4.2.1 Problem LP formulation


Linear problem definitions are often written as an optimization problem of the form:

```
minimize F(x,y) 

Subject to:

C1(x,y) <= a

C2(x,y) <= b

C3(x,y) <= c
```

where F(x,y) is the objective function, a, b and c are constants and C1(x,y), C2(x,y) and C3(x,y) are constraint functions. In programming, an LP formulation (linear program formulation) is a file of the format `.lp` that is written in a naturally algebraic formulation that can be interpreted by the linear solver (CPLEX, for example) and then solved. For more information on LP files and how they are created and used by CPLEX, read more [here](http://lpsolve.sourceforge.net/5.0/CPLEX-format.htm). An exampole LP file is shown below

```

\* Problem:example_lp_problem: Windor Glass co. [2] *\

min

F_x_y: 3 x + 5 y + const

s.t

C1_x_y: x <= 4

C2_x_y: 2 y <= 12

C3_x_y: 3 x + 2 y <= 18

C_const: const = 1.0

bounds

0 <= x <= +inf

0 <= y <= +inf

end
```

The `const` and the `C_const` terms are the constant term and its governing constraint, respectively. Linear solvers will usually add the `const` term to the lp formulation in order to minimize computation time and prevent over-using the computional capabilities of the machine it is running on, so when talking about linear problem formulations, this constant term is not normally present, but for software formulations it is an important addition.

Although a LP file is a way to write a linear program formulation and pass it to the solver to get a solution, we can also retrieve this information from the solver and use it for debugging purposes. In MathProg we can get this file from GLPK by adding the command `--wlp my_lp_file.lp` when prompting GLPK to solve the model from the command line. This command will output the lp formulation of the model into the `my_lp_file.lp` file in a similar syntax to the example above.

To get the LP file from a Pyomo model, we can prompt Python to write the file from inside the script. This can be done in the following way: 

```
filename = os.path.join(my_path, 'Log-files/pyomo_model.lp')
instance.write(filename, io_options={'symbolic_solver_labels': True})
```

The lines above will make use of the `os` Python library to write the LP formulation into the `pyomo_model.lp` file. First the empty file is created and assigned to the variable `filename`, then the model instance is written into the file by Pyomo using `instance.write()`.

## 4.2.2 Extracting model components

In the last section we explored linear program formulations and how to create files that contain the algebraic description of linear problems. We have seen that these files can be given to linear solvers, such as GLPK and solved by these solvers in the same way as a Pyomo or a MathProg model file; further we have discussed how we can ask for this file from the solver either through the command line, or from the Python script using Pyomo in combination with Python libraries for operating system manipulation.

We will now discuss and explore Pyomo functionalities that can help on the debugging process. Pyomo can be used to print other bits of model information into separate files and increase the number of available resources for debugging.

### 4.2.2.1 Printing the model

Pyomo provides us with utility functions to help us assess the state of our model. Some of these utilities can have the model output to the screen with variable, set and parameter values.

In order to output the model information to the screen, or to a separate file, we can use one of the following approaches in code:

1. Use the `display` method: `model.display()` / `instance.display()`

2. Use the `pprint()` method:  `model.pprint()` / `instance.pprint()`

The main difference between the `display()` and the `pprint()` methods is that `display()` serves as a helper function to display a quick summary of the model components, such as the number of variables and constraints in the model and the values of each component with their domains (if applicable) component size (greater than 1 if we have a vector component, for example); `pprint()` on the other hand will display all the available information from the model, or from a specific component if appended to that component (`my_parameter.pprint()`, for example prints the information from `my_´parameter` only).

A typical output from the `display()` method would look like this:

```

>>> model.disply()

Model name

Variables:

    Variable x : Size=1 Domain=Reals

    Value=1.0

    Variable y : Size=1 Domain=Reals

    Value=3.0

Objectives:

    Objective o : Size=1

    Value=4.0

Constraints:

    None
```


### 4.2.2.2 Printing variable values

In the same way we can print a model summary using the `pprint()` and `display()` methods, we can extract variable values and additional information by employing the `pprint()` method. There are two main ways to extract information from variables and output them to the screen, or to a file:

1.  Extracting from a single variable: `model.variavble_x.pprint()`

2. Extracting from all model variables: 

```
variable_log = open("./Log-files/Variables.log", "w")
for v in instance.component_data_objects(Var):
    print(str(v), v.value, file=variable_log)
```

In the second example we see that we can output information from model components into separate files by assigning the file path to a python variable, `variable_log`, and put it inside the `print()` statement together with the `value` method from Pyomo.

### 4.2.2.3 Print selected results

Another useful tool that has been developed for use in this project is the **Selected Results** file. This file contains some outputs from the model that can help us catch discrepancies between different implemntations of the same problem (like Pyomo versus MathProg, for example), or verify that the order of magnitude of the results is as expected. The access to such file can greatly decrease debugging time, allowing the programmer to rapidly identify the issue to be tackled.

To create this file, simply select what results you would wish to see and have them be printed out to a separate file. Some functions and components of the model that you might wish to check are:

* The model's objective function

* The problem bounding constraints: these are the constraints that constitute the solution space oof the model. A small change to these constraints will have a noticible impact to your objective function's output

* The model summary from your solver of choice

* Any constraint you suspect is causing issues to the expected result

# 4.3 Taking advantage of solver information

We have previously eluded to the possibility of utilizing solvers to extract additional information about the problem and the solution process, such as LP formulation, duals and slack values. In this section let us look into how we can use solvers and Pyomo to interact with solvers in order to obtain such information.

## 4.3.1 CPLEX files

The IBM CPLEX solver comes with its own [optimization studio](https://www.ibm.com/products/ilog-cplex-optimization-studio) upon installation which allows the programmer to explore the optimization model using an intuitive GUI and obtain extra information about the problem's solution. It is possible, however to access the same information by navigating CPLEX through the command line to create the relevant files we wish to study.

To run CPLEX from your command line, simply navigate to your model's folder on the command line and call CPLEX: 

```
cd my_model_path
cplex
```
After running the `cplex` command you should be greeted with the optimization studio's welcome message indicating you are now inside the solver.

In order to access the suplemental files that CPLEX cabn provide, we will first need to have the LP formulation of our problem in a `.lp` file. Then we want to have CPLEX read that problem foormulation by running thr following command: `CPLEX> read my_Problem.lp`

CPLEX will output the time spent by the solver to read that problem, which should now be loaded into the solver's memory. We can now proceed to have CPLEX produce any files we may wish. The main files we would look into and that CPLEX can produce are:

* Duals file (DUA): contains values from the problem's dual

* Solutions file (SOL): contains information about the problem's primal's solution

* Conflicting constraints file (CLP): contains information about conflicting constraints and their bounds

CPLEX allows the user to navigate in a step-by-step manner, guiding them to write the correct file each time. With the problem's LP already on the solver's memory, the process for writing any of the cited files is:

```
write my_file_name
>>> File type options:
alp          LP format problem with generic names and bound annotations
ann          Model annotations
bas          INSERT format basis file
clp          Conflict file
dpe          Binary format for dual-perturbed problem
dua          MPS format of explicit dual of problem
emb          MPS format of (embedded) network
flt          Solution pool filters
lp           LP format problem file
min          DIMACS min-cost network-flow format of (embedded) network
mps          MPS format problem file
mst          MIP start file
net          CPLEX network format of (embedded) network
ord          Integer priority order file
ppe          Binary format for primal-perturbed problem
pre          Binary format for presolved problem
prm          Non-default parameter settings
rlp          LP format problem with generic names
rew          MPS format problem with generic names
sav          Binary matrix and basis file
sol          Solution file
``` 

After getting the file type optins from CPLEX, simply select the option you want. The new file should be created in your working directory from the command line and it will comply with CPLEX's syntax for that [file format](https://www.ibm.com/docs/en/icos/20.1.0?topic=cplex-other-file-formats).

## 4.3.2 Pyomo suffixes

A suffix is solver functionality for declaring extra model data, typically in the form of solution information [4]. Pyomo allows the programmer to have access to this information through the `Suffix` component class.

As we have seen in chapter 2 of this tutorial series, Pyomo borrows many of its concepts and syntax from AMPL, suffixes are no different in this matter, as the functionality is adapted from AMPL's implementation of it as well. 

In its essence, a suffix is allowing a two-way communication between the model and the solver as the model is being solved. This way, we are able to:

* Import extra information about model solutions into Pyomo (such as duals and slack values, for example)

* Export extra information to a solver to aid in model solution (such as variable branching priority information, for example)

* Advanced component manipulation for later use in other algorithms [4].

Since suffixes allow us to communicate with the solver by both giving and extracting information from it, we need to know how to implement this functionality inside Python. To do so, we need to pass to the Suffix class a communication **direction** and, if we wish, a **datatype** to be carried through this communication process.

From Pyomo's documentation we will see the following directions and datatypes to be used by the suffixes:

1. Direction:

* `LOCAL` - suffix data stays local to the modeling framework and will not be imported or exported by a solver plugin (default)
    
* `IMPORT` - suffix data will be imported from the solver by its respective solver plugin

* `EXPORT` - suffix data will be exported to a solver by its respective solver plugin

* `IMPORT_EXPORT` - suffix data flows in both directions between the model and the solver or algorithm
 
2. Datatype:

* `FLOAT` - the suffix stores floating point data (default)

* `INT` - the suffix stores integer data

* `None` - the suffix stores any type of data

A typical suffix declaration can look as any of the following:

```
# Export integer data
model.priority = pyo.Suffix(direction=pyo.Suffix.EXPORT, datatype=pyo.Suffix.INT)

# Export and import floating point data
model.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT_EXPORT)

# Store floating point data
model.junk = pyo.Suffix()
```

From the code snippet above, we see that Pyomo can use the `Suffix` functionality to give us model duals, information about model integer and float variables, as well as floating point values for later use in debugging, or other applications. 

When working with `Abstract Models` in Pyomo, we can also create suffixes in a similar way to that of creating `Constraints`, with a component `rule` to work with variables, for example [4]: 

```
def foo_rule(m):
    return ((model.x[i], 3.0*i) for i in model.I)
model.foo = pyo.Suffix(rule=foo_rule)
-----------------------------------------------------------------------------------
>>> # instantiate the model
>>> inst = model.create_instance()
>>> for i in inst.I:
...     print((i, inst.foo[inst.x[i]]))
(1, 3.0)
(2, 6.0)
(3, 9.0)
(4, 12.0)
```
## 4.3.3 Pyomo slack values

As we have seen, it is possible to extract, amoung other things, information about the dual problem of the model using Pyomo suffixes. More than knowledge about duals, we might wish to know more about specific model components to help us debug the algorithm. A useful part of a model that can be used to debug the script and give the programmer further insight into the solution space of the program are the so called constraint **shadow prices**, or **slack values**.

Luckly, Pyomo stores these slack values for every model constraint, after the model is constructed, inside the `component_objects()` method of the model instance. Using this method we can directly access the components of our model (Sets, Parameters, Variables, Constranits and Objective Function). In order to get the slack values from our model constraints, we will simply specify `Constraint` as our component of interest to the method and then iterate through each constraint to extract the value. This is illustrated by the following code excerpt:

```
for c in instance.component_objects(Constraint, active=True):
    for index in c:
        print(c[index], " || ", c[index].lslack(), " || ", c[index].uslack(), file=dual_logfile)
```

# 4.4 Interpreting model duals for debugging

We have seen how to extract information about model duals using a solver like CPLEX to generate a duals file for us. Now let us explore how to take advantage of these files to help us in debugging our models so we can achieve the result we expect and get a better insight into our linear program formulation.

In the case of our project with OSeMOSYS, we had an original implementation in Mathprog that we wished to recreate using Pyomo, so we knew what the goal value for the model's objective function was, effectively making the dual program files a short cut into understanding how the new Pyomo model was behaving. 

With access to the dual files it is possble to simply compare them and see if any values differ, if so, indicating an implementation problem occuring under that constraint, or variable. Differet values for the objective function indicate an evident implementation problem, but how different they are will indicate how loose, or how strict the solution space is. The dual files will then indicate, together with the slack values which constraints exactly are shifting the model's solution space away fromthe expected objective value result. 
 
# 4.5 References

[1] [J.M. Garrido; Sensitivity - CS4491 Introduction to Computational Models in Python; Kennesaw State University; 2015](http://ksuweb.kennesaw.edu/~jgarrido/CS4491_notes/Sensitivity_rep.pdf)

[2] [F.S. Hillier, G.J. Lieberman; Introduction to Operations Research; 10th ed.; Chapter 4: Solving Linear Programming Problems: The Simplex Method](https://ia601802.us.archive.org/12/items/introduction-to-operations-research-10th-ed/IntroductionToOperationsResearch10thEd.pdf)

[3] [Working with Pyomo Models](https://pyomo.readthedocs.io/en/stable/working_models.html)

[4] [Pyomo Suffixes](https://pyomo.readthedocs.io/en/stable/pyomo_modeling_components/Suffixes.html)

[5] [Production Model Sensitivity Analysis](https://jckantor.github.io/ND-Pyomo-Cookbook/02.02-Production-Model-Sensitivity-Analysis.html)

[6] [Pyomo Cookbook](https://jckantor.github.io/ND-Pyomo-Cookbook/)

----------------------------------------------------------------------------------------------------------------------------------------------------

5 Final Considerations and Laying the Way Forward

# 5.1 Conclusions

This wiki summarizes the work developed at the Institute for Integrated Energy Systems at the University of Victoria to build an energy model for the province of British Columbia using the Python scripting language and the Pyomo software package for optimizatiion. In a series of 4 chapters we have walked through the purpose of the project, the reasoning behind the choice of Pyomo over MathProg for creating energy models and described the model implementation. Further we have explored a few tools that can help programmers and engineers debug their optimization models, by taking full advantage of Pyomo's powerful functionalities in conjunction with any available solver, from free software (such as GLPK) to industry leading solvers like CPLEX.

# 5.2 Recommendations

OSeMOSYS models will usually be robust, which increases running time for the solvers, and can make the debugging process take even more time. Debugging, in fact was the most time consuming component of this project.

To reduce debugging time and increase the chances of your model working in its initial tests, we recommend a modularization of the program to be carried-out. This process is as simple as dividing the model into its subcomponents (sets, parameters, variables, objectives and constraints) and creating separate files for handling different aspects of the model (objective implementation, constraints implementation, data processing, etc.). This modular approach was incorporated into our model at the end, so you can look at this repository's code to see how we went about modularizing our model. 

# 5.3 Further studying resources

[1] [Model-based Optimization: Principles and Trends - AMPL](https://ampl.com/MEETINGS/TALKS/2018_08_Lille_Tutorial1.pdf)

[2] [Tutorial for Operations Research: Modelling in GNU MathProg](https://dtk.tankonyvtar.hu/xmlui/bitstream/handle/123456789/13112/tutorial_for_operations.pdf?sequence=1&isAllowed=y)

[3] [Energy, Poverty and Development](https://iiasa.ac.at/web/home/research/Flagship-Projects/Global-Energy-Assessment/GEA_Chapter2_development_hires.pdf)

[4] [The World’s Energy Problem]( https://ourworldindata.org/worlds-energy-problem)

[5] [GNU Linear Programming Kit, Part 1: Introduction to Linear Optimization: ](http://www.osemosys.org/uploads/1/8/5/0/18504136/ceron_-_2006_-_the_gnu_linear_programming_kit_part_1_-_introduction_to_linear_optimization.pdf)

[6] [Modelling Elements of Smart Grids – Enhancing the OSeMOSYS (Open Source Energy Modelling System) Code](https://pdf.sciencedirectassets.com/271090/1-s2.0-S0360544212X00100/1-s2.0-S0360544212006299/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEP7%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJGMEQCIEHHW7w685OCY%2B%2FBmj6KOtarX4uWE4AtVOw%2FASct3PACAiAOdNRKUwERN0hM0fhO8oRYPNnVUySvNJJYzpGqi1HJdCqDBAjX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAQaDDA1OTAwMzU0Njg2NSIMAoGX%2FBtIuxSNEIBXKtcD4AoEqM8zdLNJmOz%2FJ2Pa074AnEwn3HxSz1LPvYyk4rxK6NUZAPTEfesy17Do%2BVy8HdaLVGJw6Y%2FEvI78GIsNx7Qw%2F5Siye7Itj9iw6ZpSeVXUuNV6AKyeFtgIZgoQaevcyIk%2BJfJPlED2O8eF4bjZJHndLeZMSpt8OJe1UQgPJ1%2F%2B%2BFQKm%2BqKVLPP4ol3PY%2F2zqOQ3nUUG4jnoxpIkTSsfresDrTilPdxeZefPsXgLYmxX2SzyTbe1M5ugCc54muM9R%2FZ413s4Em7qKlscCP%2BtARGAl4MGlr0pz2lZcQR91vF2KC022uY8IqxgfLvJSP5KmUFxct3U4xuuxvc24MaKk9kdjxZDoGX7J4aB2za4EVdIgjxH9E4Cx%2BEAiYXkO%2BlyHXHN4gS2Ps%2Fjy1ghLEW616fB1ZFZdRzWieLt8AMDsDOAahzujTLKjmgu%2BayfxN5V6H3TGx4%2F5sdcdt40P8uIb%2Bhmdoc7N%2FfmShgv%2FxM3X8MmHvFUnZZKcJ3iE1fKa9CJiF0HMxVi7sMRPyAP0ZXw6G18l1muaWI2DIMIm7EARECy2GwgYw0zx6xj1JjYRkTqYynvKHPkIPMYKs3IdNR7gdD4UCpd0MmT1g5iL4lAYIrle34SxoMKSOyI0GOqYBqzAJCmezK9MSZPw9kT%2BVwpA%2F6bOqXCc8w7WHCziRgehFZqN1oTTVAtG%2F68Y3Kzz7T6d%2B2wtAh5xQa%2BobfJhNxrY7BA0vvySIm%2FJfTdVx5i%2BLtrMXYU0A3ftzygUaWgtbiv9Y9w2NAEuzEOcuAvcEIbVulpeOk8kRqaoymOOs2LWq5pgk0gTLOJv%2FZ6br4e1gKhvEL4HtBoLWApw%2FQ%2BLTc85JGdZrXA%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20211209T144141Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYRKINSYHI%2F20211209%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=0c8733a76e7f206ab9fdac65039196969b267e4c1b5405bf9c02be3051f342eb&hash=fc07cbf85d1aae6b022f1e0322025f36ea6a600055aed84d8f11e93f7a3c8cf2&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0360544212006299&tid=spdf-517e9359-0e65-498b-9f88-96d493ea12eb&sid=620708ee2d609842f359c1558c01a7e84c9egxrqa&type=client)

[7] [OSeMOSYS: The Open Source Energy Modeling System An introduction to its ethos, structure and development](https://pdf.sciencedirectassets.com/271097/1-s2.0-S0301421510X00167/1-s2.0-S0301421511004897/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEP7%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJIMEYCIQCGGjmlVJRRoDGzg3f9%2B9q1PqiCSwVFOwsgUQmI39EZXwIhAOG3BBvpewgT6dhYVo5C6VO9YwlkN1ooBcddunMtWBx3KoMECNf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQBBoMMDU5MDAzNTQ2ODY1Igy69%2F2yY6m49tug%2BVUq1wN3bOY4LYHx7kknzYLzpz6TNPk%2BTXo5fVp1jI8jJ1OJz%2B3qHMHxR2rL1iEDDNxnuZTjHwgflAi1kwgFDe%2B3lawNTx0gzCMok35M32SVR5mMXJpz%2BRoqPIFfxNYl5TZPlLBW4g9ZTLuxsVTF6NgV5vjumxvIYmX2TUAnKoZpBMjw1W86Wm%2BkPcee1otNbKx3aB3nZvMTnVgv9zOPWySQazx2Rx7R%2BNWJArJQgkPb4BbE7J6rOUkqSZlNKguweFoxiwRqbzg%2BUoX43F6wADmeNwgFtTDr%2BzDVro3Cg6urlX17jRuEExdJq91Z57zzSIClRSiVKV5srs%2FHDfB1w0G6IC29dOwbls4Gz1PKQ8o0Ipav01mAPwqbXwhXILIyT5WrSq1UOA40UL5ijunGBSskRsJ6EQipAFnq9aCXIYwp%2BVF4iboLVLjikqaue3nIafvhhKqfzxVQswHmWh%2FDAM2qhHtpIku6lNrEPfb3AM3g7yX8evkdvnCBUzP7I4SznBZ2FEjxs%2BUHcmMBfhmpvY3FTp2l5xRf%2F59EmPnvHJOAX%2FZ%2Bi0Xvp3ENlzP3BaDLVbJOaeNPYFjc5Otp85G88IjgC9Hva%2FEPp0CKrWHyzn811cbA%2BWkH8B6qG9Qwho%2FIjQY6pAHNcXNMBIwYHRm%2FSrwS8Z4VGXLgcZDTHp45A8JoFMAajjxZSkBGNw5jnK1Zi6aMC%2Bnp%2F7EElxh76IaPdT2%2F8Cih%2B3Pw2UAwrvI40VEoHKPaediRlDIEGndhzJQ5l7zxu0b5Jsk6bZ4Vjaf9ZwjaDPYDwiZCKhsZqUYPytunAaMCfo9pzm0uVYmQ0mCOjaChnXCWvmRUmOHEsFhN7HhGDrteaLr93Q%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20211209T144215Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTY4OAYGPEA%2F20211209%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=931ec264c46bd922e7df68dee00ae2d885f4e6bbba55c62c370c64a99ea95700&hash=24a4e26858be80ad47b5725a7428cb7ec6c435b6997084afd7afa1532edfd3d1&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0301421511004897&tid=spdf-88d89345-ecb8-41ea-8d7a-f0b18d4cb95d&sid=620708ee2d609842f359c1558c01a7e84c9egxrqa&type=client)

[8] [Pyomo Forum - Google Groups](https://groups.google.com/g/pyomo-forum)

[9] [OSeMOSYS Forum - Google Groups](https://groups.google.com/g/osemosys)

[10] [Energy Systems Modeling Book](https://link.springer.com/book/10.1007/978-981-13-6221-7)


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Appendix: A Brief Insight Into the AMPL Modeling Language

# A.1 What is AMPL?

AMPL is a programming language for mathematical programming. It was designed and implemented in 1985 by Robert Fourer, David M. Gay, and Brian W. Kernighan, who are the authors of the [AMPL book](https://ampl.com/resources/the-ampl-book/chapter-downloads/). A mathematical programming problem is an optimization problem tackled through an algorithmic manner, which is better described through mathematical terms that are interpreted by the computer through the use of languages such as AMPL.

The problems that require the employment of AMPL usually arise from the abstraction of a real world situation, for which a model is formulated, such that its whole can be broken apart into variables, sets, parameters, constraints and the objectives, or goals of the engineering team. These problems expect real world data, most often from past iterations of the problem, or from similar occurances in different scenarios, that is then incorporated into the model and passed down to a `solver`, which produces the relevant results. The results can then be analyzed to better inform the engineers on how to refine theproblem definition to achieve the desired outcome.


# A.2 AMPL and Pyomo

As we have seen in chapter 2, Pyomo provides the same capabilities as AMPL, as such, the data files used for Pyomo models are structured in the same format as for AMPL models. Now, we shall see how these data files are written so they can be properly interpreted by the solver.

# A.3 How to Write an AMPL data file

In linear programming and mathematical programming, in general, data is represented in matrix form. In AMPL data is also represented in this way.

In a similar fashion to a Pyomo script, when creating an AMPL data file the user should declare the model's sets and parameters prefaced by the command `set` and `param`, respectively. The difference between the Pyomo and the data files, however, is that in the data file, the sets and parameters are accompained by their respective values. After declaring a set, or a parameter, the data values are to be written in a matrix-like arrangement that is similar to how they would be written mathematically.

Typically, sets are one-dimensional vectors and parameters are multidimensional matrices, of the third, fourth, or even higher orders. Let us now see some examples of declaring sets and parameters in a data file and how they are interpreted by the solver.

## Example 1: set declarations:

When declaring a set in AMPL, it can assume many different form, but the central idea behind their purpose is the sam: __they will be used to index a model parameter__, that is, they are to be understood as labels for lines and columns of a parameter matrix that will later be constructed. 

![](https://github.com/criscfer/IESVic-Pyomo-Test/blob/main/Wiki%20Images/AMPL%20Set%20Declaration%20Example.jpg)

![](https://github.com/criscfer/IESVic-Pyomo-Test/blob/main/Wiki%20Images/AMPL%20Parameter%20Declaration%20Example.jpg)

One important keyword in AMPL data files is the `default` command, which specifies a default value to be used by the solver for missing data points inside a given parameter. These missing data points can be explicitly marked by a the "." character to be replaced by the default value once the model is created and solved.

![](https://github.com/criscfer/IESVic-Pyomo-Test/blob/main/Wiki%20Images/AMPL%20Default%20Keyword%20Example.jpg)

## Example 2: multidimensional parameters:

When declaring parameters, it is important that the respective indexing sets are correctly declared within the model file (in Pyomo), but that is not necessary within data files, since the solver will deduce that any missing set will have the default value in its position. For multidimensional parameters (parameters indexed by more than one set), however, the sets must always be specified in order to construct a full matrix for that parameter. To declare a multidimensional parameter we use the square brackets ([*,*]) notation, as in the example below.

![](https://github.com/criscfer/IESVic-Pyomo-Test/blob/main/Wiki%20Images/AMPL%20Multidimensional%20Parameter%20Declaration%20Example.jpg)

This same notation can be used for as many dimensions as the parameter requires and it follows the same pattern: `param B: = [fixed_index, *] variable_index value`, where the asterisk will represenst a variable set for that declaration, while the other values within the brackets are fixed indexes for that declaration; the values that follow the closing bracket will replace the asterisks, or will represent the value to be input into the matrix by the solver, if the variable sets for that iteration have already replaced the asterisks.

# A.4 References

1. [Mathematical Programming With AMPL | Brian Kernighan and Lex Fridman](https://www.youtube.com/watch?v=gGQBpTtsRVw&list=TLPQMTYwNTIwMjIoQEz8T5s7TA&)

2. [Initializing Abstract Models with Data Command Files - Pyomo](https://link.springer.com/chapter/10.1007/978-1-4614-3226-5_6)